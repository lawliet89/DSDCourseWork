#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\begin_preamble
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\lstset{ %
  basicstyle=\footnotesize,       % the size of the fonts that are used for the code
  breakatwhitespace=false,        % sets if automatic breaks should only happen at whitespace
  breaklines=true,                % sets automatic line breaking
  captionpos=b,                   % sets the caption-position to bottom
  commentstyle=\color{dkgreen},   % comment style
  escapeinside={\%*}{*)},         % if you want to add LaTeX within your code
  keywordstyle=\color{blue},      % keyword style
  language=C,                     % the language of the code
  numbers=left,                   % where to put the line-numbers; possible values are (none, left, right)
  numberstyle=\tiny\color{gray},  % the style that is used for the line-numbers
  stringstyle=\color{mauve},      % string literal style
  tabsize=2,                      % sets default tabsize to 2 spaces
  xleftmargin=12pt,          % left margin
  frame=leftline
}

\lfoot{ywc110 \& rmb209}
\cfoot{}
\rfoot{\thepage}

\setlength{\textfloatsep}{1ex plus 0.5ex minus 0.5ex}
\setlength{\intextsep}{1ex plus 0.5ex minus 0.5ex}
%\newref{sub}{refcmd={Subsection \ref{#1}}}
\end_preamble
\use_default_options true
\begin_modules
figs-within-sections
tabs-within-sections
eqs-within-sections
customHeadersFooters
\end_modules
\maintain_unincluded_children false
\language british
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family sfdefault
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format pdf5
\output_sync 1
\bibtex_command default
\index_command default
\paperfontsize default
\spacing onehalf
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder true
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle true
\pdf_quoted_options "linkcolor=blue, bookmarks=false, pdfstartview={FitH}"
\papersize default
\use_geometry true
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2cm
\topmargin 2cm
\rightmargin 1.5cm
\bottommargin 2cm
\headheight 2cm
\secnumdepth 3
\tocdepth 2
\paragraph_separation skip
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle fancy
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Digital System Design Report
\end_layout

\begin_layout Author
Yong Wen Chua (ywc110) & Richard Bennett (rmb209)
\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Part
Determinant
\end_layout

\begin_layout Section
Setting up NIOS II
\end_layout

\begin_layout Standard
Nios II is a 32-bit embedded softcore microprocessor (a microprocessor than
 can be implemented by logic synthesis on an FPGA) Setting up the NIOS II
 system, was a relatively trivial task –following the tutorial correctly
 was all that was required.
 We first performed this on the DE2-70 board, and then later on the DE0
 board.
 As we were one of the first groups to do this – we found there was an issue
 with the compiling of Quartus projects on the lab computers – they have
 to be compiled on the H:/ drive rather than the mapped 
\backslash

\backslash
ic.ac.uk
\backslash
homes
\backslash
 drive.
 Once this issue was overcome we proceeded on to the next problem.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Nios2bdf.png
	scale 75

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Top level entity block diagram
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The system was then tested using count binary and the hello_world example
 files set out in the NIOS II Eclipse software.
 
\end_layout

\begin_layout Section
Determinant Square Matrix in Software 
\end_layout

\begin_layout Standard
The determinant of a 3x3 Matrix performed in software was done on the NIOS
 II.
 We used the LU Decomposition method to find the determinant of the matrix.
 In practice the amount of computer time used to calculate the speed of
 a program is proportional to the arithmetic and storage operations used
 to calculate the result.
 Using this measure we can calculate the LU decomposition of an NXN matrix
 to be 
\begin_inset Formula $O(n^{3})$
\end_inset

 .
 However a recursive method for finding the determinant of an NxN matrix
 is 
\begin_inset Formula $O(n!)$
\end_inset

.
 (K Eriksson – Computational Differential Equations 1996).
 The number of operations as the determinant size goes up is illustrated
 in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:complexity"

\end_inset

.
 
\end_layout

\begin_layout Standard
The algorithm used to calculate the determinant is the LU decomposition
 with Doolittle algorithm.
 (The pseudo-code used can be found at 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://vismor.com/documents/network_analysis/matrix_algorithms/S4.SS2.php
\end_layout

\end_inset

) The reason for this using this algorithm is stated above – the recursive
 (and probably simplest to implement) is 
\begin_inset Formula $O(n!)$
\end_inset

 and whereas LU decomposition is 
\begin_inset Formula $O(n^{3})$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename xcubed- xfactorial.png
	lyxscale 50
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:complexity"

\end_inset

The complexity comparison of the two big-O notations.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
The algorithm is implemented in the listing below:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

float determinant(float *matrix, int dimension){
\end_layout

\begin_layout Plain Layout

	int i, j, p;
\end_layout

\begin_layout Plain Layout

	float a, result;
\end_layout

\begin_layout Plain Layout

	float *m;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	// Let us copy the matrix first
\end_layout

\begin_layout Plain Layout

	m = (float *) malloc( sizeof(float)*dimension*dimension );
\end_layout

\begin_layout Plain Layout

	memcpy(m, matrix, sizeof(float)*dimension*dimension );
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	// First step: perform LU Decomposition using Doolittle's Method
\end_layout

\begin_layout Plain Layout

    // This algorithm will return, in the same matrix, a lower unit triangular
 matrix
\end_layout

\begin_layout Plain Layout

	// (i.e.
 diagonals one)
\end_layout

\begin_layout Plain Layout

	// and an upper trangular matrix
\end_layout

\begin_layout Plain Layout

	// https://vismor.com/documents/network_analysis/matrix_algorithms/S4.SS2.php
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	for (i = 0; i < dimension; i++){
\end_layout

\begin_layout Plain Layout

		for (j = 0; j < i; j++){
\end_layout

\begin_layout Plain Layout

			a = getAt(m, i, j, dimension);
\end_layout

\begin_layout Plain Layout

			for (p = 0; p < j; p++){
\end_layout

\begin_layout Plain Layout

				a -= getAt(m, i, p, dimension) * getAt(m, p, j, dimension);
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

			putAt(m, i, j, dimension, a/getAt(m, j, j, dimension));
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		for (j = i; j < dimension; j++){
\end_layout

\begin_layout Plain Layout

			a = getAt(m, i, j, dimension);
\end_layout

\begin_layout Plain Layout

			for (p = 0; p < i; p++){
\end_layout

\begin_layout Plain Layout

				a -= getAt(m, i, p, dimension) * getAt(m, p, j, dimension);
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

			putAt(m, i, j, dimension, a);
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	// Second step is to find the determinant.
\end_layout

\begin_layout Plain Layout

	// Because the lower triangle is a unit triangular matrix
\end_layout

\begin_layout Plain Layout

	// the determinant is simply a product of all the upper triangle diagonal
\end_layout

\begin_layout Plain Layout

	// which in this case is exactly the diagonal of m
\end_layout

\begin_layout Plain Layout

	result = 1;
\end_layout

\begin_layout Plain Layout

	for (i = 0; i < dimension; i++)
\end_layout

\begin_layout Plain Layout

		result *= getAt(m, i, i, dimension);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	free(m);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	return result;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Based on i and j, and a float pointer, get the value at row i column
 j
\end_layout

\begin_layout Plain Layout

float getAt(float *m, int i, int j, int dimension){
\end_layout

\begin_layout Plain Layout

	return *(m + i*dimension + j);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Based on i and j, and a float pointer, put the value at row i column
 j
\end_layout

\begin_layout Plain Layout

void putAt(float *m, int i, int j, int dimension, float value){
\end_layout

\begin_layout Plain Layout

	*(m + i*dimension + j) = value;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
In its most basic form, the calculation of the determinant of a 3 x 3 matrix
 for 10 iterations took 0.009s.
 Further improvements to the performance can be done.
\end_layout

\begin_layout Subsection
SDRAM Implementation
\end_layout

\begin_layout Standard
A SDRAM controller was added to the processor and the resulting connection
 in Qsys can be seen in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:QSys-connection-with"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename SDRAM qsys.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:QSys-connection-with"

\end_inset

QSys connection with SDRAM
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
The SDRAM caused a slow down in the performance due to it being slower than
 on-chip memory.
\end_layout

\begin_layout Itemize
3x3 Matrix 100 iterations: 0.077 s 
\end_layout

\begin_layout Itemize
6x6 Matrix 100 iterations 0.537 s 
\end_layout

\begin_layout Itemize
8x8 Matrix 100 iterations 1.245 s 
\end_layout

\begin_layout Itemize
10x10 Matrix 100 iterations 2.494 s 
\end_layout

\begin_layout Itemize
20x20 Matrix 100 iterations 20.343 s 
\end_layout

\begin_layout Standard
As the SDRAM is very sensitive to clock variations we added a PLL with a
 time-shift of 2.55ns.
 A PLL is a phase-locked loop, this is a closed loop feedback system based
 on the difference in phase between the clock input and a clock signal of
 a controlled oscillator.
 
\end_layout

\begin_layout Standard
The resource usage on the FPGA at this stage can be seen in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Resource-usage-on-sdram"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename SDRAM-size.png

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Resource-usage-on-sdram"

\end_inset

Resource usage on the board.
 NIOS2 and SDRAM with a PLL takes up 20% of the logic elements and 6% of
 the total memory.
 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Embedded Multipliers
\end_layout

\begin_layout Standard
Embedded Multipliers Embedded Multipliers are configured as either one 18
 x 18 multiplier or two 9 x 9 Multipliers, the Cyclone III chip on the DE0
 board has 112 Embedded 19x19 multipliers.
 
\end_layout

\begin_layout Standard
The embedded multipliers improved the performance of the determinant calculation.
\end_layout

\begin_layout Itemize
3x3 Matrix 100 iterations 0.044s 
\end_layout

\begin_layout Itemize
6x6 Matrix 100 iterations 0.283s 
\end_layout

\begin_layout Itemize
8x8 Matrix 100 iterations 0.658s 
\end_layout

\begin_layout Itemize
10x10 Matrix 100 iterations 1.278s 
\end_layout

\begin_layout Itemize
20x20 Matrix 100 iterations 10.669s 
\end_layout

\begin_layout Standard
The resource usage can be seen in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Resource-usage-with-embedded-mul"

\end_inset

.Using Embedded Multipliers uses 1% (212) more logic elements on the board,
 and uses an additional 4 Embedded Multipliers.
 It uses 248 more registers.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename SDRAM-EmbeddedMultipliers-size.png

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Resource-usage-with-embedded-mul"

\end_inset

Resource usage with embedded mulitplier.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
LUT – based Multipliers 
\end_layout

\begin_layout Standard
In addition to embedded multipliers, there are also look-up tables on the
 cyclone II chip created from M9K memory blocks.
 Look-up tables are implemented using very small amounts of RAM, and are
 used to implement combinational logic – for example an N-input LUT can
 implement any Boolean function of N inputs.
 
\end_layout

\begin_layout Itemize
3x3 Matrix 0.045s
\end_layout

\begin_layout Itemize
6x6 Matrix 0.286s
\end_layout

\begin_layout Itemize
8x8 Matrix 0.666s
\end_layout

\begin_layout Itemize
10x10 Matrix 1.293s
\end_layout

\begin_layout Itemize
20x20 Matrix 10.72s
\end_layout

\begin_layout Standard
Using LUTs uses 2% more logic elements than the SDRAM alone, 281 more registers.
 See 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Resource-usage-with-lut"

\end_inset

 for the resource usage.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename SDRam-LUT-size.png

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Resource-usage-with-lut"

\end_inset

Resource usage with LUT-based multipliers.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
From the data and the graph it can be seen that the SDRAM alone is the slowest
 for all Matrix dimensions and Embedded Multipliers are the fastest.
 However there are only a few tens of milliseconds difference over 100 iteration
s between the LUT and Embedded Multipliers, this will make a minimal difference
 over 1 iteration – however if we were to want to do one million iterations
 of a 20x20 matrix would make a 510 second difference between using LUTs
 and Embedded Multipliers, so in terms of speed it makes sense to use Embedded
 Multipliers.
 
\end_layout

\begin_layout Standard
However on the DE0 board there are only 112 Embedded multipliers, but 15000
 Lookup tables – so if a larger project was undertaken then it would be
 sensible to put the most time sensitive calculations onto Embedded Multipliers
 and the rest on to the Lookup tables.
 
\end_layout

\begin_layout Subsection
External Floating Point Hardware Accelerator
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Floating Point Bdf.png
	lyxscale 50
	scale 45

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Block diagram of the floating point ALU
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
To create the floating point custom instruction hardware, the megawizard
 function blocks were used.
 The exponent and mantissa widths were set to 8 bits and 23bits respectively
 for all blocks.
 The latency for the floating point blocks were 5, 6 and 7 cycles for the
 floating point multiply, divide and add/subtract block respectively.
 As we are not trying to overclock the NIOS2 CPU clock to over 50MHz choosing
 the lowest latency will not cause any problems.
 The lowest latency also uses the smallest size on the FPGA so for our requireme
nts this seems to be the optimal design choice – smallest size and fastest
 operation.
 However if we had wanted to increase the frequency of the clock we would
 have had to choose a higher latency to allow for more pipelines states
 within the Floating point unit to shorten the critical path.
 The hardware is invoked in NIOS via a NIOS custom instruction slave interface.
\end_layout

\begin_layout Standard
As an extension to this Floating Point ALU a bypass operation was added
 in for 0, 1, NAN and infinity as they are neutral, or absorbent, elements
 in addition and multiplication, according to the floating point standard.
 This extension was implemented in the Verilog file fp_alu_improved.v which
 can be seen in the 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:fp-alu"

\end_inset

.
\end_layout

\begin_layout Standard
The ALU improved the performance significantly:
\end_layout

\begin_layout Itemize
3x3 Matrix 100 iterations 0.016s
\end_layout

\begin_layout Itemize
6x6 Matrix 100 iterations 0.035s
\end_layout

\begin_layout Itemize
8x8 Matrix100 iterations 0.058s
\end_layout

\begin_layout Itemize
10x10 Matrix 100 iterations 0.09s
\end_layout

\begin_layout Itemize
20x20 Matrix 100 iterations 0.489s
\end_layout

\begin_layout Standard
The resource usage can be seen in Adding a floating point Arithmetic and
 Logic unit to calculate the determinant of the matrix has increased the
 number of logic elements by 9% of the total available.
 The total memory usage increased by 1% and the number of embedded multipliers
 used has increased by 19 elements (17%).
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename fp_determinant-size.png

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Reosurce usage with dedicated floating point ALU hardware.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Performance Comparison
\end_layout

\begin_layout Standard
A comparison of the performance for all the various implementations above
 can be seen in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Performance"

\end_inset

.
 It can be seen that even with running the code on the SDRAM, the dedicated
 floating point ALU unit has performance that far exceeds all the rest.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename performance-chart.png
	lyxscale 50
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Performance"

\end_inset

Performance comparison of all the different implementataions.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
External Determinant Hardware Accelerator
\end_layout

\begin_layout Subsection
Hardware Design
\end_layout

\begin_layout Standard
Due to the nature of the LU Decomposition modifying the values of the matrix
 in situ for further computation later on there is no way to simply cache
 any particular column or row of the matrix we used the RAM to cache the
 entire matrix, which is instantiated using an M9K memory block.
 
\end_layout

\begin_layout Subsection
Hardware Implementation
\end_layout

\begin_layout Standard
The Verilog implementation uses a state machine consisting of 5 states.
 
\end_layout

\begin_layout Standard
The first state (state 0) is the idle state where the hardware is ready
 to compute.
 If invoked with a non-zero address via the Custom Instruction slave interface,
 the hardware will proceed to the second state and return “99” to the processor.
 If the dimension of the matrix is less than one it will return “-1” to
 the processor to indicate its idle status.
 
\end_layout

\begin_layout Standard
The second state (state 1) is the read from SDRAM state where data is read
 from the word addressed SDRAM addressed (so the next word is found by adding
 4 to the address – 4 bytes to a word).
 There is just one cycle latency in reading from SDRAM, this is achieved
 by using the Avalon slave which co-ordinates the reading data from SDRAM
 – to request a new address from RAM we wait for the waitRequest signal
 to go low (a sign that Avalon Slave has received our previous request)
 and the read signal to be high.
 We can then increment to the next address.
 To receive the data from the address we wait for the readdatavalid signal
 to be high and the ramwritedone signal must remain low.
 The reason for separate request and receive states as there is could be
 an indeterminate amount of time between requesting and receiving so it
 will be more efficient these two issues.
 Due to the nature of the Avalon bus we therefore know that the request
 and then receive will be sent in the correct order.
 When this data is read from SDRAM it is moved to RAM generated by an M9K
 memory block.
 
\end_layout

\begin_layout Standard
The third state (state 2) – is the Doolittle’s LU Decomposition algorithm
 state, there are many stages due to the 
\end_layout

\begin_layout Standard
Instead of swapping the contents of memory locations when row swapping is
 required we instead swap the memory addresses of the data, which is faster
 than memory swaps.
 
\end_layout

\begin_layout Standard
The fourth state (state 3) – is the Diagonal Multiplication state – where
 diagonals of the matrix are multiplied.
 
\end_layout

\begin_layout Standard
The fifth and final state (state 4) is the result output state – the done
 values are set high and the result is passed to the Avalon slave.
 
\end_layout

\begin_layout Standard
For small dimension sizes (less than 4X4), it may be faster to do the matrix
 calculations in software if you had a data caches as NIOS could then perform
 single cycle reads which will be significantly faster than reading from
 SDRAM in the hardware determinant implementation.
 However once we get past these small sizes of MATRIX the hardware determinant
 implementation will always be faster, providing we have enough memory to
 perform the calculations.
 4 M9Ks are enough to store one 32x 32 matrix, and 16M9Ks are required to
 store one 64X64 matrix.
 It can be seen that as the matrix size doubles the number of M9Ks required
 squares.
 This is gets close to the limit of space that available on the DE0 board.
\end_layout

\begin_layout Subsection
Possible extensions to the project
\end_layout

\begin_layout Standard
Multiple NIOS II on the FPGA – should in theory be able to get 4 NIOS II
 on the FPGA.
 
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part
Notch Filter
\end_layout

\begin_layout Standard
A notch filter is to be implemented to filter a wave file that is corrupted
 by a single 1 KHz tone.
 The filter's implementation is first tested in software using C++ code
 first, before actually implementing it in hardware.
 
\end_layout

\begin_layout Section
Design Consideration
\end_layout

\begin_layout Standard
Two classes of filters are available for implementation: Finite Impulse
 Response (FIR) or Infinite Impulse Response (IIR) filters.
 FIR filters have the advantage of being stable and not subjected to feedback.
 FIR filters also have linear phase, which is simply a group delay of the
 input and will not cause any non-linear phase shifts in the output.
 However, to acheive a sharp roll-off, particularly when we only want to
 filter out a certain frequency, a high number of taps are required.
 Combined with the fact that we need to quantise the inputs, along with
 limitatons, having a high order filter is not desirable.
 On the other hand, IIR filters can acheive a sharper roll-off with very
 low orders.
 But IIR filters do not offer non-linear phase shifts, and can become unstable
 due to feedback.
 When combined with quantisation errors, the filter may become unstable.
 
\end_layout

\begin_layout Standard
An IIR filter was eventually chosen for implementation.
 This was chosen primarily for:
\end_layout

\begin_layout Itemize
Sharp roll-off of IIR filters with low orders
\end_layout

\begin_layout Itemize
Phase shifts are generally not picked up by the human ears, unless they
 are very specific phase shifts.
\end_layout

\begin_layout Itemize
Ease of implementation
\end_layout

\begin_layout Standard
However, care must be taken during quantisation and scaling so as not to
 cause the filter to become unstable.
 A second order IIR filter is chosen to be implemented for sake of simplicity.
 The difference equation for the 
\begin_inset Formula $k$
\end_inset


\begin_inset script superscript

\begin_layout Plain Layout
th
\end_layout

\end_inset

 output 
\begin_inset Formula $y(k)$
\end_inset

 based on the 
\begin_inset Formula $k$
\end_inset


\begin_inset script superscript

\begin_layout Plain Layout
th 
\end_layout

\end_inset

input 
\begin_inset Formula $x(k)$
\end_inset

 is given by:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
y(k)=b_{0}x(k)+b_{1}x(k-1)+b_{2}x(k-2)-a_{1}y(k-1)-a_{2}y(k-2)\label{eq:iir-diff-eq}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
where 
\begin_inset Formula $a_{0},a_{1},b_{0},b_{1},b_{2}$
\end_inset

 are coefficients to be designed.
 
\end_layout

\begin_layout Subsection
Quantisation Considerations
\end_layout

\begin_layout Standard
The inputs are 8 bits, and the output was thus chosen to be 8 bits as well.
 In order to reduce quantisation errors, the coefficients are represented
 with 32 bits.
 For a second order, the coefficients are of the range 
\begin_inset Formula $-2\leqslant a_{i},b_{i}\leqslant2$
\end_inset

 and are thus scaled by the scaling constant 
\begin_inset Formula $S_{c}=2^{30}$
\end_inset

.
 Based on 
\begin_inset CommandInset ref
LatexCommand formatted
reference "eq:iir-diff-eq"

\end_inset

, the bit lengths of the intermediate values are then computed using interval
 arithmetic, and are shown in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:interval-arith"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="5">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0pt">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Quantity
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Symbol
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Lower Interval
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Upper Interval
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
No.
 of Bits
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Input (and delayed inputs)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
e.g 
\begin_inset Formula $x(k)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-128
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
127 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Delayed outputs
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
e.g 
\begin_inset Formula $y(k-1)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-128
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
127 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Coefficients
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $S_{c}a_{i}$
\end_inset

 or 
\begin_inset Formula $S_{c}b_{i}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-2147483648 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2147483647 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
32
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Multiplication with coefficients
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
e.g.
 
\begin_inset Formula $S_{c}a_{i}x(k)$
\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $-2.7273\times10^{11}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $2.7273\times10^{11}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
39
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Accumulation of multiplication
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $S_{c}y(k)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $-8.24634\times10^{11}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $8.24634\times10^{11}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
41
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Output
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $y(k)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-767
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
768 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
11
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:interval-arith"

\end_inset

Number of bits for the various intermediate quantities during computation
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
It can be seen from 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:interval-arith"

\end_inset

 that the output, after dividing with 
\begin_inset Formula $S_{c}$
\end_inset

 still requires 11 bits to fully represent its value.
 We will be truncating this to 8 bits in the delayed outputs buffer and
 the actual output, or the number of bits required will increase exponentially
 as computation goes on.
 
\end_layout

\begin_layout Standard
After scaling the coefficients, the difference equation becomes: 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
S_{c}y(k)=S_{c}\left[b_{0}x(k)+b_{1}x(k-1)+b_{2}x(k-2)-a_{1}y(k-1)-a_{2}y(k-2)\right]\label{eq:iir-diff-scaled}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
and the calculated output has to be divided by 
\begin_inset Formula $S_{c}$
\end_inset

 first before writing.
\end_layout

\begin_layout Subsection
Quantisation Tests
\end_layout

\begin_layout Standard
In order to test the effects of calculating in fixed point rather than double-pr
evision floating point, a simple C++ program was written to calculate the
 expected output, along with the bit truncation that occurs.
 The code can be found in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:C++-Simulation-Code"

\end_inset

.
 
\end_layout

\begin_layout Standard
The C++ program reads in the normalised samples and coefficients from text
 input files, scales them accordingly, performs the sum described in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "eq:iir-diff-scaled"

\end_inset

, and then unscales the output accordingly.
 This program was then used to aid in the design of filter coefficients
\end_layout

\begin_layout Subsection
Filter Design
\end_layout

\begin_layout Standard
The design of the coefficients involves the selection of the proper 
\begin_inset Formula $Q$
\end_inset

-factor.
 A high 
\begin_inset Formula $Q$
\end_inset

-factor will cause a sharper drop-off at the notch frequency (resulting
 in a smaller 3 dB bandwidth) while attenuating the output less.
 A low 
\begin_inset Formula $Q$
\end_inset

-factor will cause more attenuation at the notch frequency while causing
 the drop-off to be less (i.e.
 a bigger 3 dB bandwidth).
 Given the Nyquist frequency 
\begin_inset Formula $\nicefrac{f_{s}}{2}=22050\unit{Hz}$
\end_inset

 and the notch frequency at 
\begin_inset Formula $\omega_{0}=1000\unit{Hz}$
\end_inset

.
 Then, given the 
\begin_inset Formula $Q$
\end_inset

-factor 
\begin_inset Formula $q$
\end_inset

, the 3 dB bandwidth is given by 
\begin_inset Formula $\omega_{3dB}=\nicefrac{\omega_{0}}{q}$
\end_inset

.
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename fft-noise.png
	lyxscale 40
	scale 40

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:noisy-dft"

\end_inset

DFT of noisy signal.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
The DFT of the noisy signal is given in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:noisy-dft"

\end_inset

.
 It can be seen that to reduce the tone at 1 kHz to an acceptable level,
 approximately 30 dB of attenuation is needed.
 The 
\begin_inset Formula $Q$
\end_inset

-factor was chosen to be 13.75 for this purpose, as it acheives the right
 balance between attenuation and 3 dB bandwidth minimisation.
 The frequency response of the filter is given in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:freqz-dp"

\end_inset

, and the filtered signal (in double precision) compared against the original
 signal is given in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:fft-dp"

\end_inset

.
 It can be seen that it acheives the appropriate attenuation, and the listening
 tests confirms this.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename iir-matlab.png
	lyxscale 50
	scale 46

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:freqz-dp"

\end_inset

Frequency Response of Matlab designed filter, calculated at double precision.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename iir-matlab-fft.png
	lyxscale 50
	scale 46

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:fft-dp"

\end_inset

FFT comparison of the original sound file and the filtered version.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Caption

\begin_layout Plain Layout
Matlab designed second order filter response
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The coefficients are then put through the C++ program (described above)
 to test the effects of quantisation.
 The results are given in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:c++-simulated"

\end_inset

.
 It can be seen that quantisation has introduced additional noise and caused
 attenuation of the lower frequencies.
 Further tests show that a higher 
\begin_inset Formula $Q$
\end_inset

-factor will cause even more noise to be generated as the coefficients need
 more precision and quantisation has removed some these precision, potentially
 causing the poles of the filter to become unstable.
 However, a low 
\begin_inset Formula $Q$
\end_inset

-factor with its higher attenuation and higher 3 dB bandwidth combined with
 quantisation errors caused more of the frequency components around 1 kHz
 to be attentuated.
 Since most of the sound is about 1 kHz (see 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:noisy-dft"

\end_inset

), this causes the output to be adversely affected.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename iir-simulate.png
	lyxscale 50
	scale 46

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:c++-simulated"

\end_inset

Comparison of the FFT between the Matlab computation (double precision)
 and C++ simulation (fixed point)
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Hardware Implementation
\end_layout

\begin_layout Standard
The hardware filter block is implemented to interact with the NIOS process
 via means of a NIOS custom instruction slave.
 It will read and write from the SDRAM using an Avalon master interface.
 Finally, it offers an Avalon Slave interface for its settings (coefficients)
 to be changed and status of calculation to be checked.
 Finally, it implements an Avalon interrupt to notify the NIOS processor
 that is done processing (to allow the processor to perform other tasks).The
 Verilog code for its implementation can be found in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:Verilog-Implementation"

\end_inset

.
\end_layout

\begin_layout Subsection
Hardware Interface
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement O
overhang 0in
width "50col%"
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename iir-block.jpg
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:notch-signals"

\end_inset

The input and output signals of the hardware block, grouped by their interfaces.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename qsys-interconnect.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:qsys-all"

\end_inset

Interconnection of all the components in QSys, for parts I and II.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
The input and output signals of the hardware block can be seen in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:notch-signals"

\end_inset

.
 Its connection in Qsys with the rest of the components can be seen in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:qsys-all"

\end_inset

.
\end_layout

\begin_layout Subsubsection
NIOS Custom Instruction Slave
\end_layout

\begin_layout Standard
The computation of the filtering is done via an invocation of a custom instructi
on through the NIOS Custom Instruction Slave.
 The custom instruction only expects one argument: the address where the
 first sample is stored at.
 When the hardware block is ready and has accepted the invocation to start
 computation, it will return a value of 
\begin_inset Quotes eld
\end_inset

99
\begin_inset Quotes erd
\end_inset

 to the CPU.
 This should be taken as the sign that computation has begun.
 If the argument has a value of zero, a number indicating the status of
 the system will be returned to the CPU.
 If the system is idle and ready to accept new invocations, it will return
 
\begin_inset Quotes eld
\end_inset

-1
\begin_inset Quotes erd
\end_inset

.
 If the hardware block is in the process of computation, it will return
 the sample number that has been written back to SDRAM successfully.
 If the hardware block is waiting for its interrupt request (IRQ) to be
 serviced, it will return the number 
\begin_inset Quotes eld
\end_inset

-2
\begin_inset Quotes erd
\end_inset

.
 
\end_layout

\begin_layout Subsubsection
Avalon Master
\end_layout

\begin_layout Standard
An Avalon Master is implemented to read and write results to the SDRAM.
 Samples are expected to be stored, and are written in 32 bit signed integers
 with little endian byte ordering.
 This decision stemmed primarily to allow ease of analysis using the software
 written for the NIOS processor, and can be further optimised as described
 later.
 The number of samples is provided via a write to the Avalon Slave (see
 below), and the address to process the samples from is provided via an
 invocation through the NIOS Custom Instruction Slave (above).
 Samples are read, computed, and overwritten with the results 
\emph on
in situ
\emph default
.
 A flag, writable through the Avalon Slave, can instruct the hardware to
 actually write the results or to simply compute them and discard them.
\end_layout

\begin_layout Subsubsection
Avalon Slave & Avalon Interrupt
\end_layout

\begin_layout Standard
The Avalon Slave allows for settings to be changed, and for internal status
 flags to be checked.
 The full list can be seen in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:Avalon-Slave"

\end_inset

.
 The meanings of the various internal flags will be described later.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="15" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="left" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Address
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Read
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Write
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Number of samples requested from SDRAM
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Overwrite Result Flag
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Request FIFO Usage
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $S_{c}a_{1}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Read FIFO Usage
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $S_{c}a_{2}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Number of samples read from SDRAM
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $S_{c}b_{0}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Samples discarded form SDRAM (should always be zero)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $S_{c}b_{1}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Calculation stage
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $S_{c}b_{2}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Number of samples computed
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
N/A
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Number of samples written to SDRAM
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
N/A
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Write FIFO Usage
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
N/A
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(Avalon Master) read
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
N/A
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(Avalon Master) waitrequest
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
N/A
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
11
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(Avalon Master) write
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
N/A
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Stage of operation
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
N/A
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
13
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Overwrite Result Flag
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
N/A
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:Avalon-Slave"

\end_inset

Avalon Slave read and write contents at various addresses.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
An Avalon Interrupt interface is implemented to interrupt the NIOS processor
 to notify it that computation of all samples are complete.
 The interrupt service routine should then perform a read on the slave to
 clear the IRQ.
 It does not matter which content is read.
\end_layout

\begin_layout Subsection
Hardware Operation
\end_layout

\begin_layout Subsubsection
Idle State
\end_layout

\begin_layout Standard
The hardware exists at the top level as a finite state machine with three
 states (c.f.
 
\begin_inset Quotes eld
\end_inset

Stage of operation
\begin_inset Quotes erd
\end_inset

 in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:Avalon-Slave"

\end_inset

).
 The first state (stage 0) is the idle state where the hardware is ready
 to compute.
 If invoked with a non-zero address via the Custom Instruction slave intercace,
 the hardware will proceed to the second state and return 
\begin_inset Quotes eld
\end_inset

99
\begin_inset Quotes erd
\end_inset

 to the processor.
 If invoked with a zero address, it will return 
\begin_inset Quotes eld
\end_inset

-1
\begin_inset Quotes erd
\end_inset

 to the processor to indicate its idle status.
\end_layout

\begin_layout Subsubsection
Computation State
\end_layout

\begin_layout Standard
Four operations need to be completed during the computation state (stage
 1): requesting a fetch from the SDRAM (
\begin_inset Quotes eld
\end_inset

request pipeline
\begin_inset Quotes erd
\end_inset

), receive sample from the SDRAM (
\begin_inset Quotes eld
\end_inset

receive pipeline
\begin_inset Quotes erd
\end_inset

), calculate the output (
\begin_inset Quotes eld
\end_inset

calculate pipeline
\begin_inset Quotes erd
\end_inset

), and write the output (
\begin_inset Quotes eld
\end_inset

write pipeline
\begin_inset Quotes erd
\end_inset

).
 Due to the fact that each of these processes take different amount of time
 to complete, and in the case of SDRAM operations, the amount of time can
 be unspecified, these processes are implemented as four separate pipelines,
 analogous to four different threads.
 
\end_layout

\begin_layout Standard
These four pipelines communicate with each other via three different FIFO
 buffers: 
\begin_inset Quotes eld
\end_inset

request FIFO
\begin_inset Quotes erd
\end_inset

 between the request and calculate pipeline, 
\begin_inset Quotes eld
\end_inset

read FIFO
\begin_inset Quotes erd
\end_inset

 between the receive and calculate pipeline, and 
\begin_inset Quotes eld
\end_inset

write FIFO
\begin_inset Quotes erd
\end_inset

 between the calculate and write pipeline.
 These FIFO buffers serve to pass data from one pipeline to the other.
 Data generally flows from the request, to receive, to calculate and finally
 to the write pipeline.
 The FIFO buffers also serve to block the upstream process if buffers are
 full.
 
\end_layout

\begin_layout Standard
In general, the calculation pipeline would be expected to take the most
 amount of computation time, and the SDRAM read and writes should be sufficientl
y quick, barring any high load on the SDRAM from other components in the
 system.
 Thus, it is expected that the receive and read FIFO would be filled most
 of the time, and the request and receive pipeline would thus be more likely
 to be blocked.
 The FIFOs were chosen to be 32 words deep to balance between FPGA resource
 usage and pipeline saturation.
 The calculation pipeline is much slower than the rest and increasing the
 depth of the FIFO would not increase throughput and only waste resources.
 Reducing the FIFO to being too shallow might cause starvation to the calculatio
n pipeline as the SDRAM reads might be too slow, due to the variable amount
 of time it takes to read, and write.
 
\end_layout

\begin_layout Subsubsection*
Request Pipeline
\end_layout

\begin_layout Standard
The request pipeline sends request to the SDRAM to read data.
 As per the Avalon interface specification, when the 
\begin_inset Quotes eld
\end_inset

waitrequest
\begin_inset Quotes erd
\end_inset

 signal goes low, the pipeline would take it as a sign that the request
 has been accepted by the Avalon slave.
 At the same time, it fills the request FIFO.
 If the request FIFO is not full, it will proceed to request the next sample.
 Otherwise, it yields the 
\begin_inset Quotes eld
\end_inset

read
\begin_inset Quotes erd
\end_inset

 signal, and stops requesting for new samples.
 When request FIFO is not full, and a 
\begin_inset Quotes eld
\end_inset

write
\begin_inset Quotes erd
\end_inset

 operation is not taking place, it will restart the requests.
 
\end_layout

\begin_layout Subsubsection*
Receive Pipeline
\end_layout

\begin_layout Standard
Due to the fact that it can take an unspecified number of cycles between
 requesting and receiving a sample, the receive pipeline is necessary.
 When the 
\begin_inset Quotes eld
\end_inset

readdatavalid
\begin_inset Quotes erd
\end_inset

 signal is high, the receive pipeline will fill the read FIFO with the data.
 If the FIFO is full, it will discard the data.
 This is not likely to happen due to the use of the request FIFO, and is
 simply a safeguard.
 
\end_layout

\begin_layout Subsubsection*
Calculate Pipeline
\end_layout

\begin_layout Standard
The calculate pipeline exists as a state machine for the various stages
 of the calculation (see calculation stage in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:Avalon-Slave"

\end_inset

).
 In its idle state, if the read FIFO is not empty, it will drain the read
 FIFO.
 Also, it will drain the request FIFO so that the request pipeline can request
 for new samples.
 It then calculates the output over several clock cycles according to 
\begin_inset CommandInset ref
LatexCommand formatted
reference "eq:iir-diff-scaled"

\end_inset

.
 Finally, it will wait for the write FIFO to not be full, and write to it.
 It will then return to its idle state.
\end_layout

\begin_layout Subsubsection*
Write Pipeline
\end_layout

\begin_layout Standard
The write pipeline exists as a state machine for various stages of write.
 In its idle state, it will watch if the write FIFO has any content.
 It will then drain the value from the FIFO.
 Next, it will check to see if a 
\begin_inset Quotes eld
\end_inset

read
\begin_inset Quotes erd
\end_inset

 operation is taking place, before starting its 
\begin_inset Quotes eld
\end_inset

write
\begin_inset Quotes erd
\end_inset

 operation.
 Once 
\begin_inset Quotes eld
\end_inset

waitrequest
\begin_inset Quotes erd
\end_inset

 goes low, it will go back to its idle state.
\end_layout

\begin_layout Standard
When all the samples have been calculated and written, and IRQ will be asserted,
 and the hardware will wait for an Avalon slave read to be performed (stage
 3) before going back to its idle state (stage 0).
\end_layout

\begin_layout Subsubsection*
Reader Priority
\end_layout

\begin_layout Standard
Due to the long latency in calculation, and the fact that only one read
 or write operation can be performed on the SDRAM at any time, the request
 pipeline is given priorty over the write pipeline.
 This is so that the necessary buffers can be filled up first so that calculatio
n can take place as the writing is essentially much faster.
 The request pipeline will only yield when the buffers are full.
 Care was also taken to prevent deadlocks when both reads and writes are
 waiting on each other to complete.
 
\end_layout

\begin_layout Subsection
Evaluation
\end_layout

\begin_layout Standard
The output of the notch filter is comparable with that of the C++ simulation
 as seen in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:c++-simulated"

\end_inset

 with the same quantisation issues.
\end_layout

\begin_layout Standard
The notch filter takes 0.376 seconds to process 963144 samples.
 Thus, it has an average throughput of 
\begin_inset Formula ${\textstyle \nicefrac{963144}{0.376}\approx2561553}$
\end_inset

 samples per second.
 Further enhancements can be made to increase the throughput, and will be
 described below.
 The filter performs very quickly and can perform real-time filtering, even
 with a sampling rate of 44.1 kHz.
 
\end_layout

\begin_layout Subsection
Further Enhancements
\end_layout

\begin_layout Standard
The calculation pipeline can itself be further pipelined to increase its
 throughput by interleaving several calculations.
 While the latency will not be reduced, it can yield a higher throughput.
 
\end_layout

\begin_layout Standard
The hardware block can also be designed to act as a biquad filter with cascaded
 second order IIR filters.
 This, however, can increase the requirements for the bit widths of the
 intermediates and increase complexity as the values have to be multipled
 with yet another gain value in between the second order IIR filter blocks.
 
\end_layout

\begin_layout Standard
Each sample could also have been stored as 8 bits signed integers in the
 SDRAM rather than as 32 bits signed integers.
 This would allow a single word read from SDRAM operation to obtain four
 samples at one go, rather than one at a time.
 This could increase throughput by up to four times.
 The samples could also have been written to result as 8 bits signed integers,
 and thus allow four samples to be stored per word in the SDRAM.
 This would also increase the complexity in the logic for the receive and
 write pipeline.
\end_layout

\begin_layout Standard
\start_of_appendix
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Description of Files Submitted
\end_layout

\begin_layout Standard
The files for Part I and Part II are combined together in one archive as
 they are integrated together.
 The C file will invoke both the components together.
 
\end_layout

\begin_layout Subsection*
Hardware Block Files
\end_layout

\begin_layout Itemize
ip/fp_alu.bdf
\series bold
 - Block Diagram for the FP ALU
\end_layout

\begin_layout Itemize
ip/fp_alu_improved.v 
\series bold
- Bypass improvement for the FP ALU
\end_layout

\begin_layout Itemize
ip/fp_det_nios.v 
\series bold
- Verilog code for the determinant component
\end_layout

\begin_layout Itemize
ip/notch.v
\series bold
 - Notch filter Verilog code
\end_layout

\begin_layout Subsection*
C Files
\end_layout

\begin_layout Itemize

\series bold
Eclipse Projects
\series default
: software/
\end_layout

\begin_layout Itemize
software/software/hello_world.c - 
\series bold
NIOS Code
\end_layout

\begin_layout Itemize
notch_files/test/test.cpp - 
\series bold
Notch simluation of fixed point notch filter
\end_layout

\begin_layout Itemize
notch_files/test/coeff.txt - 
\series bold
Coefficients Loaded by the Simulation
\end_layout

\begin_layout Itemize
notch_files/test/wav.txt - 
\series bold
Input samples
\end_layout

\begin_layout Standard
In addition, the entire code base can be found on a Git repository at 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://github.com/lawliet89/DSDCourseWork
\end_layout

\end_inset

.
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:fp-alu"

\end_inset

Improved Floating Point ALU Verilog Implementation
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "../ip/fp_alu_improved.v"
lstparams "language=Verilog"

\end_inset


\end_layout

\begin_layout Section
NIOS C File
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "../software/software/hello_world.c"

\end_inset


\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:C++-Simulation-Code"

\end_inset

Notch Filter C++ Simulation Code
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "../notch_files/test/test.cpp"

\end_inset


\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Verilog-Implementation"

\end_inset

Notch Filter Verilog Implementation
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "../ip/notch.v"
lstparams "language=Verilog"

\end_inset


\end_layout

\end_body
\end_document
